---
title: "Getting Started with imagerExtara"
author: "Shota Ochi"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with imagerExtara}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type="text/css">

body, td {
   font-size: 15px;
}
code.r{
  font-size: 15px;
}
pre {
  font-size: 15px
}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=FALSE, 
               comment=NA, verbose=TRUE, fig.width=5, fig.height=5, dev='jpeg',dev.args=list(quality=50))			   
```

imagerExtra provides several advanced functions for image processing based on **imager**.

See the vignettes of **imager** if you aren't familiar with **imager**.

The functions in imagerExtra are classified into 4 groups by their function.

* Contrast Enhancement
* Image Segmentation
* Image Denoising
* Others

See below to know what functions are implemented.

<br />

## Preparation

Most of the functions in imagerExtra are for grayscale image.

See the vignette "Treating Color Image with imagerExtra" if you want to treat color image with imagerExtra.

Let's prepare a grayscale image.

```{r, fig.width=3, fig.height=3, message=FALSE, dev='jpeg'}
library(imagerExtra)
g <- grayscale(boats)
plot(g)
```

<br />

## Contrast Enhancement

The functions for contrast enhancement are 

* EqualizePiecewise
* BalanceSimplest
* SPE

### EqualizePiecewise (Piecewise Affine Histogram Equalization)

EqualizePiecewise has three parameters: *N*, *smin*, and *smax*.

However, we should not change *smin*. 

See [Jose-Luis Lisani, et al., IPOL, 2 (2012), pp. 243-265.](https://doi.org/10.5201/ipol.2012.lps-pae) for detail.

The parameter *N* controls how the input gray level will be mapped in the output image. 

We don't have a priori choice for *N*. You will tune *N* mainly.

The parameter *smax* controls the upper limit of contrast stretching.

If you want to prevent excessive enhancement of contrast, you should make *smax* low.

```{r, fig.width=8, fig.height=8, dev='jpeg'}
layout(matrix(1:4, 2, 2))
plot(g, main = "Original")
plot(EqualizePiecewise(g, 2), main = "N = 2")
plot(EqualizePiecewise(g, 10), main = "N = 10")
plot(EqualizePiecewise(g, 1000), main = "N = 1000")
```

### BalanceSimplest (Simplest Color Balance)

BalanceSimplest saturates a percentage *sleft* % of the pixels on the left side of the histogram, 

and a percentage *sright* % of the pixels on the right side of the histogram.

See [Nicolas Limare, et al., IPOL, 1 (2011), pp. 297-315.](https://doi.org/10.5201/ipol.2011.llmps-scb) for detail.

```{r, fig.width=7, fig.height=7, dev='jpeg'}
layout(matrix(1:2, 1, 2))
plot(g, main = "Original")
plot(BalanceSimplest(g, 1, 1), main = "sleft = 1, sright = 1")
```

### SPE (Screened Poisson Equation)

The distinction of SPE is that SPE corrects the inhomogeneous background of image.

See [Jean-Michel Morel, et al., IPOL, 4 (2014), pp. 16-29.](https://doi.org/10.5201/ipol.2014.84) for detail.

The parameter *lamda* controls how strong corrects inhomogeneous background of image.

SPE corrects inhomogeneous background strongly if *lamda* is large.

```{r, fig.width=7, fig.height=7, dev='jpeg'}
layout(matrix(1:2, 1, 2))
gbirds <- load.example("birds") %>% grayscale()
plot(gbirds, main = "Original")
plot(SPE(gbirds, 0.01), main = "SPE (lamda = 0.01)")
```

<br />

## Image Denoising

The function for image denoising is

* DenoiseDCT

### DenoiseDCT (DCT denoising)

DCT denoising is a simple and effective denoising algorithm using local DCT thresholding.

See [Guoshen Yu, and Guillermo Sapiro, IPOL, 1 (2011), pp. 292-296.](https://doi.org/10.5201/ipol.2011.ys-dct) for detail.

The parameter *sdn* determines how strong denoise a image.

Noise is strongly denoised if *sdn* is large.

The parameter *flag_dct16x16* determiens window size of local patches. 

DenoiseDCT uses 8x8 windows or 16x16 window.

Larger window size does not bring significant improvement when noise level is low.

Larger window size outperforms significantly smaller window size when noise level is low.

```{r, fig.width=7, fig.height=7, dev='jpeg'}
noisy <- g + imnoise(dim = dim(g), sd = 0.1)
layout(matrix(c(1,3,2,4), 2, 2))
plot(g, main = "Original")
plot(noisy, main = "Noisy Boats")
DenoiseDCT(noisy, 0.1) %>% plot(., main = "Denoised (8x8 window)")
DenoiseDCT(noisy, 0.1, flag_dct16x16 = TRUE) %>% plot(., main = "Denoised (16x16 window)")
```

<br />

## Image Segmentation

The functions for image segmentation are

* ThresholdTriclass
* ThresholdAdaptive

### ThresholdTriclass (Iterative Triclass Thresholding)

Iterative triclass thresholding is an iterative thresholding technique.

We need to set a rule to stop iteration.

We have two options.

* set preset threshold (*stopval*)
* set repeat number (*repeatnum*)

```{r, fig.width=7, fig.height=7}
gdogs <- grayscale(dogs)
layout(matrix(1:4, 2, 2, byrow = TRUE))
plot(gdogs, main = "Original", axes=F)
ThresholdTriclass(gdogs, stopval = 0.001) %>% plot(main = "stopval = 0.001")
ThresholdTriclass(gdogs, repeatnum = 1) %>% plot(main = "repeatnum = 1")
ThresholdTriclass(gdogs, repeatnum = 3) %>% plot(main = "repeatnum = 3")
```

### ThresholdAdaptive (Local Adaptive Thresholding)

Local adaptive thresholding can extract objects from inhomogeneous background.

You will tune the two paramters k and windowsize.

Note that the parameter *range* determines max standard deviation.

you should set *range* as [0,1] if you treat a image whose pixel values are in [0,1]. 

```{r, fig.height=3}
layout(matrix(1:2,1,2))
plot(papers, main = "Original")
hello <- ThresholdAdaptive(papers, 0.1, windowsize = 17, range = c(0,1))
plot(hello, main = "Binarizesd")
```

## Others

The functions classified as others are

* Grayscale
* GetHue
* RestoreHue
* OCR
* OCR_data

### Grayscale, GetHue, and RestoreHue

These functions are for treating color image with imagerExtra.

See the vignette "Treating Color Image with imagerExtra" for detail.

### OCR and OCR_data

These functions are shortcuts to the ocr function and ocr_data function of the R package **tesseract**.

See the vignette "Optical Character Recognition with imagerExtra" for detail.